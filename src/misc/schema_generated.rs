// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod ws_api {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_ACTION: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_ACTION: i8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_ACTION: [Action; 13] = [
  Action::SR_INIT_CONSUMER,
  Action::SR_INIT_TRANSPORTS,
  Action::SR_PING,
  Action::SM_BROADCAST,
  Action::SM_SESSION_LEAVE,
  Action::SM_INFO_CHANGE,
  Action::CR_CONNECT_CTS_TRANSPORT,
  Action::CR_CONNECT_STC_TRANSPORT,
  Action::CR_INIT_PRODUCER,
  Action::CM_BROADCAST,
  Action::CM_CONSUMPTION_CHANGE,
  Action::CM_INFO_CHANGE,
  Action::CM_PRODUCER_CHANGE,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Action(pub i8);
#[allow(non_upper_case_globals)]
impl Action {
  pub const SR_INIT_CONSUMER: Self = Self(0);
  pub const SR_INIT_TRANSPORTS: Self = Self(1);
  pub const SR_PING: Self = Self(2);
  pub const SM_BROADCAST: Self = Self(3);
  pub const SM_SESSION_LEAVE: Self = Self(4);
  pub const SM_INFO_CHANGE: Self = Self(5);
  pub const CR_CONNECT_CTS_TRANSPORT: Self = Self(6);
  pub const CR_CONNECT_STC_TRANSPORT: Self = Self(7);
  pub const CR_INIT_PRODUCER: Self = Self(8);
  pub const CM_BROADCAST: Self = Self(9);
  pub const CM_CONSUMPTION_CHANGE: Self = Self(10);
  pub const CM_INFO_CHANGE: Self = Self(11);
  pub const CM_PRODUCER_CHANGE: Self = Self(12);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::SR_INIT_CONSUMER,
    Self::SR_INIT_TRANSPORTS,
    Self::SR_PING,
    Self::SM_BROADCAST,
    Self::SM_SESSION_LEAVE,
    Self::SM_INFO_CHANGE,
    Self::CR_CONNECT_CTS_TRANSPORT,
    Self::CR_CONNECT_STC_TRANSPORT,
    Self::CR_INIT_PRODUCER,
    Self::CM_BROADCAST,
    Self::CM_CONSUMPTION_CHANGE,
    Self::CM_INFO_CHANGE,
    Self::CM_PRODUCER_CHANGE,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::SR_INIT_CONSUMER => Some("SR_INIT_CONSUMER"),
      Self::SR_INIT_TRANSPORTS => Some("SR_INIT_TRANSPORTS"),
      Self::SR_PING => Some("SR_PING"),
      Self::SM_BROADCAST => Some("SM_BROADCAST"),
      Self::SM_SESSION_LEAVE => Some("SM_SESSION_LEAVE"),
      Self::SM_INFO_CHANGE => Some("SM_INFO_CHANGE"),
      Self::CR_CONNECT_CTS_TRANSPORT => Some("CR_CONNECT_CTS_TRANSPORT"),
      Self::CR_CONNECT_STC_TRANSPORT => Some("CR_CONNECT_STC_TRANSPORT"),
      Self::CR_INIT_PRODUCER => Some("CR_INIT_PRODUCER"),
      Self::CM_BROADCAST => Some("CM_BROADCAST"),
      Self::CM_CONSUMPTION_CHANGE => Some("CM_CONSUMPTION_CHANGE"),
      Self::CM_INFO_CHANGE => Some("CM_INFO_CHANGE"),
      Self::CM_PRODUCER_CHANGE => Some("CM_PRODUCER_CHANGE"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Action {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Action {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Action {
    type Output = Action;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Action {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Action {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Action {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MEDIA_KIND: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MEDIA_KIND: i8 = 1;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MEDIA_KIND: [MediaKind; 2] = [
  MediaKind::audio,
  MediaKind::video,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MediaKind(pub i8);
#[allow(non_upper_case_globals)]
impl MediaKind {
  pub const audio: Self = Self(0);
  pub const video: Self = Self(1);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 1;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::audio,
    Self::video,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::audio => Some("audio"),
      Self::video => Some("video"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MediaKind {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MediaKind {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MediaKind {
    type Output = MediaKind;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MediaKind {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MediaKind {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MediaKind {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MEDIA_TYPE: i8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MEDIA_TYPE: i8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MEDIA_TYPE: [MediaType; 3] = [
  MediaType::audio,
  MediaType::camera,
  MediaType::screen,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MediaType(pub i8);
#[allow(non_upper_case_globals)]
impl MediaType {
  pub const audio: Self = Self(0);
  pub const camera: Self = Self(1);
  pub const screen: Self = Self(2);

  pub const ENUM_MIN: i8 = 0;
  pub const ENUM_MAX: i8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::audio,
    Self::camera,
    Self::screen,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::audio => Some("audio"),
      Self::camera => Some("camera"),
      Self::screen => Some("screen"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MediaType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MediaType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<i8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for MediaType {
    type Output = MediaType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<i8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for MediaType {
  type Scalar = i8;
  #[inline]
  fn to_little_endian(self) -> i8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: i8) -> Self {
    let b = i8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MediaType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    i8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MediaType {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_CONTENT: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_CONTENT: u8 = 12;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_CONTENT: [Content; 13] = [
  Content::NONE,
  Content::SrInitConsumerPayload,
  Content::SrInitTransportsPayload,
  Content::SmBroadcastPayload,
  Content::SmSessionLeavePayload,
  Content::SmInfoChangePayload,
  Content::CrConnectCtsTransportPayload,
  Content::CrConnectStcTransportPayload,
  Content::CrInitProducerPayload,
  Content::CmBroadcastPayload,
  Content::CmConsumptionChangePayload,
  Content::CmInfoChangePayload,
  Content::CmProducerChangePayload,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct Content(pub u8);
#[allow(non_upper_case_globals)]
impl Content {
  pub const NONE: Self = Self(0);
  pub const SrInitConsumerPayload: Self = Self(1);
  pub const SrInitTransportsPayload: Self = Self(2);
  pub const SmBroadcastPayload: Self = Self(3);
  pub const SmSessionLeavePayload: Self = Self(4);
  pub const SmInfoChangePayload: Self = Self(5);
  pub const CrConnectCtsTransportPayload: Self = Self(6);
  pub const CrConnectStcTransportPayload: Self = Self(7);
  pub const CrInitProducerPayload: Self = Self(8);
  pub const CmBroadcastPayload: Self = Self(9);
  pub const CmConsumptionChangePayload: Self = Self(10);
  pub const CmInfoChangePayload: Self = Self(11);
  pub const CmProducerChangePayload: Self = Self(12);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 12;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::SrInitConsumerPayload,
    Self::SrInitTransportsPayload,
    Self::SmBroadcastPayload,
    Self::SmSessionLeavePayload,
    Self::SmInfoChangePayload,
    Self::CrConnectCtsTransportPayload,
    Self::CrConnectStcTransportPayload,
    Self::CrInitProducerPayload,
    Self::CmBroadcastPayload,
    Self::CmConsumptionChangePayload,
    Self::CmInfoChangePayload,
    Self::CmProducerChangePayload,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::SrInitConsumerPayload => Some("SrInitConsumerPayload"),
      Self::SrInitTransportsPayload => Some("SrInitTransportsPayload"),
      Self::SmBroadcastPayload => Some("SmBroadcastPayload"),
      Self::SmSessionLeavePayload => Some("SmSessionLeavePayload"),
      Self::SmInfoChangePayload => Some("SmInfoChangePayload"),
      Self::CrConnectCtsTransportPayload => Some("CrConnectCtsTransportPayload"),
      Self::CrConnectStcTransportPayload => Some("CrConnectStcTransportPayload"),
      Self::CrInitProducerPayload => Some("CrInitProducerPayload"),
      Self::CmBroadcastPayload => Some("CmBroadcastPayload"),
      Self::CmConsumptionChangePayload => Some("CmConsumptionChangePayload"),
      Self::CmInfoChangePayload => Some("CmInfoChangePayload"),
      Self::CmProducerChangePayload => Some("CmProducerChangePayload"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for Content {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for Content {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
    Self(b)
  }
}

impl flatbuffers::Push for Content {
    type Output = Content;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        flatbuffers::emplace_scalar::<u8>(dst, self.0);
    }
}

impl flatbuffers::EndianScalar for Content {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for Content {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Content {}
pub struct ContentUnionTableOffset {}

pub enum SrInitConsumerPayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SrInitConsumerPayload<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SrInitConsumerPayload<'a> {
  type Inner = SrInitConsumerPayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SrInitConsumerPayload<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;
  pub const VT_KIND: flatbuffers::VOffsetT = 6;
  pub const VT_PRODUCER_ID: flatbuffers::VOffsetT = 8;
  pub const VT_TRANSPORT_ID: flatbuffers::VOffsetT = 10;
  pub const VT_RTP_PARAMETERS: flatbuffers::VOffsetT = 12;
  pub const VT_SESSION_ID: flatbuffers::VOffsetT = 14;
  pub const VT_TYPE_: flatbuffers::VOffsetT = 16;
  pub const VT_ACTIVE: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SrInitConsumerPayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SrInitConsumerPayloadArgs<'args>
  ) -> flatbuffers::WIPOffset<SrInitConsumerPayload<'bldr>> {
    let mut builder = SrInitConsumerPayloadBuilder::new(_fbb);
    if let Some(x) = args.session_id { builder.add_session_id(x); }
    if let Some(x) = args.rtp_parameters { builder.add_rtp_parameters(x); }
    if let Some(x) = args.transport_id { builder.add_transport_id(x); }
    if let Some(x) = args.producer_id { builder.add_producer_id(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    builder.add_active(args.active);
    builder.add_type_(args.type_);
    builder.add_kind(args.kind);
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SrInitConsumerPayload::VT_ID, None)}
  }
  #[inline]
  pub fn kind(&self) -> MediaKind {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MediaKind>(SrInitConsumerPayload::VT_KIND, Some(MediaKind::audio)).unwrap()}
  }
  #[inline]
  pub fn producer_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SrInitConsumerPayload::VT_PRODUCER_ID, None)}
  }
  #[inline]
  pub fn transport_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SrInitConsumerPayload::VT_TRANSPORT_ID, None)}
  }
  #[inline]
  pub fn rtp_parameters(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SrInitConsumerPayload::VT_RTP_PARAMETERS, None)}
  }
  #[inline]
  pub fn session_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SrInitConsumerPayload::VT_SESSION_ID, None)}
  }
  #[inline]
  pub fn type_(&self) -> MediaType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MediaType>(SrInitConsumerPayload::VT_TYPE_, Some(MediaType::audio)).unwrap()}
  }
  #[inline]
  pub fn active(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SrInitConsumerPayload::VT_ACTIVE, Some(false)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SrInitConsumerPayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .visit_field::<MediaKind>("kind", Self::VT_KIND, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("producer_id", Self::VT_PRODUCER_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("transport_id", Self::VT_TRANSPORT_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("rtp_parameters", Self::VT_RTP_PARAMETERS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("session_id", Self::VT_SESSION_ID, false)?
     .visit_field::<MediaType>("type_", Self::VT_TYPE_, false)?
     .visit_field::<bool>("active", Self::VT_ACTIVE, false)?
     .finish();
    Ok(())
  }
}
pub struct SrInitConsumerPayloadArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub kind: MediaKind,
    pub producer_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub transport_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub rtp_parameters: Option<flatbuffers::WIPOffset<&'a str>>,
    pub session_id: Option<flatbuffers::WIPOffset<&'a str>>,
    pub type_: MediaType,
    pub active: bool,
}
impl<'a> Default for SrInitConsumerPayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    SrInitConsumerPayloadArgs {
      id: None,
      kind: MediaKind::audio,
      producer_id: None,
      transport_id: None,
      rtp_parameters: None,
      session_id: None,
      type_: MediaType::audio,
      active: false,
    }
  }
}

pub struct SrInitConsumerPayloadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SrInitConsumerPayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SrInitConsumerPayload::VT_ID, id);
  }
  #[inline]
  pub fn add_kind(&mut self, kind: MediaKind) {
    self.fbb_.push_slot::<MediaKind>(SrInitConsumerPayload::VT_KIND, kind, MediaKind::audio);
  }
  #[inline]
  pub fn add_producer_id(&mut self, producer_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SrInitConsumerPayload::VT_PRODUCER_ID, producer_id);
  }
  #[inline]
  pub fn add_transport_id(&mut self, transport_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SrInitConsumerPayload::VT_TRANSPORT_ID, transport_id);
  }
  #[inline]
  pub fn add_rtp_parameters(&mut self, rtp_parameters: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SrInitConsumerPayload::VT_RTP_PARAMETERS, rtp_parameters);
  }
  #[inline]
  pub fn add_session_id(&mut self, session_id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SrInitConsumerPayload::VT_SESSION_ID, session_id);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: MediaType) {
    self.fbb_.push_slot::<MediaType>(SrInitConsumerPayload::VT_TYPE_, type_, MediaType::audio);
  }
  #[inline]
  pub fn add_active(&mut self, active: bool) {
    self.fbb_.push_slot::<bool>(SrInitConsumerPayload::VT_ACTIVE, active, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SrInitConsumerPayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SrInitConsumerPayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SrInitConsumerPayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SrInitConsumerPayload<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SrInitConsumerPayload");
      ds.field("id", &self.id());
      ds.field("kind", &self.kind());
      ds.field("producer_id", &self.producer_id());
      ds.field("transport_id", &self.transport_id());
      ds.field("rtp_parameters", &self.rtp_parameters());
      ds.field("session_id", &self.session_id());
      ds.field("type_", &self.type_());
      ds.field("active", &self.active());
      ds.finish()
  }
}
pub enum SrInitTransportsPayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SrInitTransportsPayload<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SrInitTransportsPayload<'a> {
  type Inner = SrInitTransportsPayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SrInitTransportsPayload<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SrInitTransportsPayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SrInitTransportsPayloadArgs<'args>
  ) -> flatbuffers::WIPOffset<SrInitTransportsPayload<'bldr>> {
    let mut builder = SrInitTransportsPayloadBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SrInitTransportsPayload::VT_ID, None)}
  }
}

impl flatbuffers::Verifiable for SrInitTransportsPayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct SrInitTransportsPayloadArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SrInitTransportsPayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    SrInitTransportsPayloadArgs {
      id: None,
    }
  }
}

pub struct SrInitTransportsPayloadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SrInitTransportsPayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SrInitTransportsPayload::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SrInitTransportsPayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SrInitTransportsPayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SrInitTransportsPayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SrInitTransportsPayload<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SrInitTransportsPayload");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum SmBroadcastPayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SmBroadcastPayload<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SmBroadcastPayload<'a> {
  type Inner = SmBroadcastPayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SmBroadcastPayload<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SmBroadcastPayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SmBroadcastPayloadArgs<'args>
  ) -> flatbuffers::WIPOffset<SmBroadcastPayload<'bldr>> {
    let mut builder = SmBroadcastPayloadBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SmBroadcastPayload::VT_ID, None)}
  }
}

impl flatbuffers::Verifiable for SmBroadcastPayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct SmBroadcastPayloadArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SmBroadcastPayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    SmBroadcastPayloadArgs {
      id: None,
    }
  }
}

pub struct SmBroadcastPayloadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SmBroadcastPayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SmBroadcastPayload::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SmBroadcastPayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SmBroadcastPayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SmBroadcastPayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SmBroadcastPayload<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SmBroadcastPayload");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum SmSessionLeavePayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SmSessionLeavePayload<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SmSessionLeavePayload<'a> {
  type Inner = SmSessionLeavePayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SmSessionLeavePayload<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SmSessionLeavePayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SmSessionLeavePayloadArgs<'args>
  ) -> flatbuffers::WIPOffset<SmSessionLeavePayload<'bldr>> {
    let mut builder = SmSessionLeavePayloadBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SmSessionLeavePayload::VT_ID, None)}
  }
}

impl flatbuffers::Verifiable for SmSessionLeavePayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct SmSessionLeavePayloadArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SmSessionLeavePayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    SmSessionLeavePayloadArgs {
      id: None,
    }
  }
}

pub struct SmSessionLeavePayloadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SmSessionLeavePayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SmSessionLeavePayload::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SmSessionLeavePayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SmSessionLeavePayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SmSessionLeavePayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SmSessionLeavePayload<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SmSessionLeavePayload");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum SmInfoChangePayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SmInfoChangePayload<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SmInfoChangePayload<'a> {
  type Inner = SmInfoChangePayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> SmInfoChangePayload<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SmInfoChangePayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SmInfoChangePayloadArgs<'args>
  ) -> flatbuffers::WIPOffset<SmInfoChangePayload<'bldr>> {
    let mut builder = SmInfoChangePayloadBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(SmInfoChangePayload::VT_ID, None)}
  }
}

impl flatbuffers::Verifiable for SmInfoChangePayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct SmInfoChangePayloadArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for SmInfoChangePayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    SmInfoChangePayloadArgs {
      id: None,
    }
  }
}

pub struct SmInfoChangePayloadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SmInfoChangePayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(SmInfoChangePayload::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SmInfoChangePayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SmInfoChangePayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SmInfoChangePayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SmInfoChangePayload<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SmInfoChangePayload");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum CrConnectCtsTransportPayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CrConnectCtsTransportPayload<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CrConnectCtsTransportPayload<'a> {
  type Inner = CrConnectCtsTransportPayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CrConnectCtsTransportPayload<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CrConnectCtsTransportPayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CrConnectCtsTransportPayloadArgs<'args>
  ) -> flatbuffers::WIPOffset<CrConnectCtsTransportPayload<'bldr>> {
    let mut builder = CrConnectCtsTransportPayloadBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrConnectCtsTransportPayload::VT_ID, None)}
  }
}

impl flatbuffers::Verifiable for CrConnectCtsTransportPayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct CrConnectCtsTransportPayloadArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CrConnectCtsTransportPayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    CrConnectCtsTransportPayloadArgs {
      id: None,
    }
  }
}

pub struct CrConnectCtsTransportPayloadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CrConnectCtsTransportPayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrConnectCtsTransportPayload::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CrConnectCtsTransportPayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CrConnectCtsTransportPayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CrConnectCtsTransportPayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CrConnectCtsTransportPayload<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CrConnectCtsTransportPayload");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum CrConnectStcTransportPayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CrConnectStcTransportPayload<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CrConnectStcTransportPayload<'a> {
  type Inner = CrConnectStcTransportPayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CrConnectStcTransportPayload<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CrConnectStcTransportPayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CrConnectStcTransportPayloadArgs<'args>
  ) -> flatbuffers::WIPOffset<CrConnectStcTransportPayload<'bldr>> {
    let mut builder = CrConnectStcTransportPayloadBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrConnectStcTransportPayload::VT_ID, None)}
  }
}

impl flatbuffers::Verifiable for CrConnectStcTransportPayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct CrConnectStcTransportPayloadArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CrConnectStcTransportPayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    CrConnectStcTransportPayloadArgs {
      id: None,
    }
  }
}

pub struct CrConnectStcTransportPayloadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CrConnectStcTransportPayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrConnectStcTransportPayload::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CrConnectStcTransportPayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CrConnectStcTransportPayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CrConnectStcTransportPayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CrConnectStcTransportPayload<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CrConnectStcTransportPayload");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum CrInitProducerPayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CrInitProducerPayload<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CrInitProducerPayload<'a> {
  type Inner = CrInitProducerPayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CrInitProducerPayload<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CrInitProducerPayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CrInitProducerPayloadArgs<'args>
  ) -> flatbuffers::WIPOffset<CrInitProducerPayload<'bldr>> {
    let mut builder = CrInitProducerPayloadBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CrInitProducerPayload::VT_ID, None)}
  }
}

impl flatbuffers::Verifiable for CrInitProducerPayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct CrInitProducerPayloadArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CrInitProducerPayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    CrInitProducerPayloadArgs {
      id: None,
    }
  }
}

pub struct CrInitProducerPayloadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CrInitProducerPayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CrInitProducerPayload::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CrInitProducerPayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CrInitProducerPayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CrInitProducerPayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CrInitProducerPayload<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CrInitProducerPayload");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum CmBroadcastPayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CmBroadcastPayload<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CmBroadcastPayload<'a> {
  type Inner = CmBroadcastPayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CmBroadcastPayload<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CmBroadcastPayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CmBroadcastPayloadArgs<'args>
  ) -> flatbuffers::WIPOffset<CmBroadcastPayload<'bldr>> {
    let mut builder = CmBroadcastPayloadBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CmBroadcastPayload::VT_ID, None)}
  }
}

impl flatbuffers::Verifiable for CmBroadcastPayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct CmBroadcastPayloadArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CmBroadcastPayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    CmBroadcastPayloadArgs {
      id: None,
    }
  }
}

pub struct CmBroadcastPayloadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CmBroadcastPayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CmBroadcastPayload::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CmBroadcastPayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CmBroadcastPayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CmBroadcastPayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CmBroadcastPayload<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CmBroadcastPayload");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum CmConsumptionChangePayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CmConsumptionChangePayload<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CmConsumptionChangePayload<'a> {
  type Inner = CmConsumptionChangePayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CmConsumptionChangePayload<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CmConsumptionChangePayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CmConsumptionChangePayloadArgs<'args>
  ) -> flatbuffers::WIPOffset<CmConsumptionChangePayload<'bldr>> {
    let mut builder = CmConsumptionChangePayloadBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CmConsumptionChangePayload::VT_ID, None)}
  }
}

impl flatbuffers::Verifiable for CmConsumptionChangePayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct CmConsumptionChangePayloadArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CmConsumptionChangePayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    CmConsumptionChangePayloadArgs {
      id: None,
    }
  }
}

pub struct CmConsumptionChangePayloadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CmConsumptionChangePayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CmConsumptionChangePayload::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CmConsumptionChangePayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CmConsumptionChangePayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CmConsumptionChangePayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CmConsumptionChangePayload<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CmConsumptionChangePayload");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum CmInfoChangePayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CmInfoChangePayload<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CmInfoChangePayload<'a> {
  type Inner = CmInfoChangePayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CmInfoChangePayload<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CmInfoChangePayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CmInfoChangePayloadArgs<'args>
  ) -> flatbuffers::WIPOffset<CmInfoChangePayload<'bldr>> {
    let mut builder = CmInfoChangePayloadBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CmInfoChangePayload::VT_ID, None)}
  }
}

impl flatbuffers::Verifiable for CmInfoChangePayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct CmInfoChangePayloadArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CmInfoChangePayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    CmInfoChangePayloadArgs {
      id: None,
    }
  }
}

pub struct CmInfoChangePayloadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CmInfoChangePayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CmInfoChangePayload::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CmInfoChangePayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CmInfoChangePayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CmInfoChangePayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CmInfoChangePayload<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CmInfoChangePayload");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum CmProducerChangePayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct CmProducerChangePayload<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for CmProducerChangePayload<'a> {
  type Inner = CmProducerChangePayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> CmProducerChangePayload<'a> {
  pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    CmProducerChangePayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CmProducerChangePayloadArgs<'args>
  ) -> flatbuffers::WIPOffset<CmProducerChangePayload<'bldr>> {
    let mut builder = CmProducerChangePayloadBuilder::new(_fbb);
    if let Some(x) = args.id { builder.add_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(CmProducerChangePayload::VT_ID, None)}
  }
}

impl flatbuffers::Verifiable for CmProducerChangePayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct CmProducerChangePayloadArgs<'a> {
    pub id: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CmProducerChangePayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    CmProducerChangePayloadArgs {
      id: None,
    }
  }
}

pub struct CmProducerChangePayloadBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> CmProducerChangePayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_id(&mut self, id: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(CmProducerChangePayload::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> CmProducerChangePayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CmProducerChangePayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<CmProducerChangePayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for CmProducerChangePayload<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("CmProducerChangePayload");
      ds.field("id", &self.id());
      ds.finish()
  }
}
pub enum MessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
  type Inner = Message<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table::new(buf, loc) }
  }
}

impl<'a> Message<'a> {
  pub const VT_ACTION: flatbuffers::VOffsetT = 4;
  pub const VT_CONTENT_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_CONTENT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Message { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MessageArgs
  ) -> flatbuffers::WIPOffset<Message<'bldr>> {
    let mut builder = MessageBuilder::new(_fbb);
    if let Some(x) = args.content { builder.add_content(x); }
    builder.add_content_type(args.content_type);
    builder.add_action(args.action);
    builder.finish()
  }


  #[inline]
  pub fn action(&self) -> Action {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Action>(Message::VT_ACTION, Some(Action::SR_INIT_CONSUMER)).unwrap()}
  }
  #[inline]
  pub fn content_type(&self) -> Content {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Content>(Message::VT_CONTENT_TYPE, Some(Content::NONE)).unwrap()}
  }
  #[inline]
  pub fn content(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Message::VT_CONTENT, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_sr_init_consumer_payload(&self) -> Option<SrInitConsumerPayload<'a>> {
    if self.content_type() == Content::SrInitConsumerPayload {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SrInitConsumerPayload::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_sr_init_transports_payload(&self) -> Option<SrInitTransportsPayload<'a>> {
    if self.content_type() == Content::SrInitTransportsPayload {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SrInitTransportsPayload::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_sm_broadcast_payload(&self) -> Option<SmBroadcastPayload<'a>> {
    if self.content_type() == Content::SmBroadcastPayload {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SmBroadcastPayload::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_sm_session_leave_payload(&self) -> Option<SmSessionLeavePayload<'a>> {
    if self.content_type() == Content::SmSessionLeavePayload {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SmSessionLeavePayload::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_sm_info_change_payload(&self) -> Option<SmInfoChangePayload<'a>> {
    if self.content_type() == Content::SmInfoChangePayload {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SmInfoChangePayload::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_cr_connect_cts_transport_payload(&self) -> Option<CrConnectCtsTransportPayload<'a>> {
    if self.content_type() == Content::CrConnectCtsTransportPayload {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CrConnectCtsTransportPayload::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_cr_connect_stc_transport_payload(&self) -> Option<CrConnectStcTransportPayload<'a>> {
    if self.content_type() == Content::CrConnectStcTransportPayload {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CrConnectStcTransportPayload::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_cr_init_producer_payload(&self) -> Option<CrInitProducerPayload<'a>> {
    if self.content_type() == Content::CrInitProducerPayload {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CrInitProducerPayload::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_cm_broadcast_payload(&self) -> Option<CmBroadcastPayload<'a>> {
    if self.content_type() == Content::CmBroadcastPayload {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CmBroadcastPayload::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_cm_consumption_change_payload(&self) -> Option<CmConsumptionChangePayload<'a>> {
    if self.content_type() == Content::CmConsumptionChangePayload {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CmConsumptionChangePayload::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_cm_info_change_payload(&self) -> Option<CmInfoChangePayload<'a>> {
    if self.content_type() == Content::CmInfoChangePayload {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CmInfoChangePayload::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn content_as_cm_producer_change_payload(&self) -> Option<CmProducerChangePayload<'a>> {
    if self.content_type() == Content::CmProducerChangePayload {
      self.content().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { CmProducerChangePayload::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Message<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Action>("action", Self::VT_ACTION, false)?
     .visit_union::<Content, _>("content_type", Self::VT_CONTENT_TYPE, "content", Self::VT_CONTENT, false, |key, v, pos| {
        match key {
          Content::SrInitConsumerPayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SrInitConsumerPayload>>("Content::SrInitConsumerPayload", pos),
          Content::SrInitTransportsPayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SrInitTransportsPayload>>("Content::SrInitTransportsPayload", pos),
          Content::SmBroadcastPayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SmBroadcastPayload>>("Content::SmBroadcastPayload", pos),
          Content::SmSessionLeavePayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SmSessionLeavePayload>>("Content::SmSessionLeavePayload", pos),
          Content::SmInfoChangePayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SmInfoChangePayload>>("Content::SmInfoChangePayload", pos),
          Content::CrConnectCtsTransportPayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CrConnectCtsTransportPayload>>("Content::CrConnectCtsTransportPayload", pos),
          Content::CrConnectStcTransportPayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CrConnectStcTransportPayload>>("Content::CrConnectStcTransportPayload", pos),
          Content::CrInitProducerPayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CrInitProducerPayload>>("Content::CrInitProducerPayload", pos),
          Content::CmBroadcastPayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CmBroadcastPayload>>("Content::CmBroadcastPayload", pos),
          Content::CmConsumptionChangePayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CmConsumptionChangePayload>>("Content::CmConsumptionChangePayload", pos),
          Content::CmInfoChangePayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CmInfoChangePayload>>("Content::CmInfoChangePayload", pos),
          Content::CmProducerChangePayload => v.verify_union_variant::<flatbuffers::ForwardsUOffset<CmProducerChangePayload>>("Content::CmProducerChangePayload", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct MessageArgs {
    pub action: Action,
    pub content_type: Content,
    pub content: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MessageArgs {
  #[inline]
  fn default() -> Self {
    MessageArgs {
      action: Action::SR_INIT_CONSUMER,
      content_type: Content::NONE,
      content: None,
    }
  }
}

pub struct MessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_action(&mut self, action: Action) {
    self.fbb_.push_slot::<Action>(Message::VT_ACTION, action, Action::SR_INIT_CONSUMER);
  }
  #[inline]
  pub fn add_content_type(&mut self, content_type: Content) {
    self.fbb_.push_slot::<Content>(Message::VT_CONTENT_TYPE, content_type, Content::NONE);
  }
  #[inline]
  pub fn add_content(&mut self, content: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_CONTENT, content);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Message<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Message");
      ds.field("action", &self.action());
      ds.field("content_type", &self.content_type());
      match self.content_type() {
        Content::SrInitConsumerPayload => {
          if let Some(x) = self.content_as_sr_init_consumer_payload() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Content::SrInitTransportsPayload => {
          if let Some(x) = self.content_as_sr_init_transports_payload() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Content::SmBroadcastPayload => {
          if let Some(x) = self.content_as_sm_broadcast_payload() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Content::SmSessionLeavePayload => {
          if let Some(x) = self.content_as_sm_session_leave_payload() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Content::SmInfoChangePayload => {
          if let Some(x) = self.content_as_sm_info_change_payload() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Content::CrConnectCtsTransportPayload => {
          if let Some(x) = self.content_as_cr_connect_cts_transport_payload() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Content::CrConnectStcTransportPayload => {
          if let Some(x) = self.content_as_cr_connect_stc_transport_payload() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Content::CrInitProducerPayload => {
          if let Some(x) = self.content_as_cr_init_producer_payload() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Content::CmBroadcastPayload => {
          if let Some(x) = self.content_as_cm_broadcast_payload() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Content::CmConsumptionChangePayload => {
          if let Some(x) = self.content_as_cm_consumption_change_payload() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Content::CmInfoChangePayload => {
          if let Some(x) = self.content_as_cm_info_change_payload() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        Content::CmProducerChangePayload => {
          if let Some(x) = self.content_as_cm_producer_change_payload() {
            ds.field("content", &x)
          } else {
            ds.field("content", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("content", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Message`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Message>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_message_unchecked`.
pub fn size_prefixed_root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Message>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Message` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn size_prefixed_root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Message`.
pub unsafe fn root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::root_unchecked::<Message>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Message`.
pub unsafe fn size_prefixed_root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::size_prefixed_root_unchecked::<Message>(buf)
}
#[inline]
pub fn finish_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod ws_api

